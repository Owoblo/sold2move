import { supabase } from '@/lib/customSupabaseClient';
import { handleDatabaseError, handleQueryError, retryWithBackoff } from '@/lib/errorHandler';

// Utility function to get the most recent run that has data
export async function getMostRecentRunWithData() {
  try {
    const { data: runsWithData, error: runsError } = await supabase
      .from('runs')
      .select('id')
      .order('started_at', { ascending: false });
    
    if (runsError) {
      throw handleDatabaseError(runsError, 'getMostRecentRunWithData', { 
        table: 'runs',
        operation: 'select_runs' 
      });
    }
    
    if (!runsWithData || runsWithData.length === 0) {
      throw new Error('No runs found in database');
    }
    
    // Since just_listed doesn't have run_id column, just return the most recent run
    // and let the calling function handle the data fetching
    return runsWithData[0].id;
  } catch (error) {
    throw error;
  }
}

export async function fetchJustListed(runId, cityName, page = 1, pageSize = 20, filters = {}) {
  try {
    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    // Since just_listed doesn't have run_id column, we'll just use the provided runId
    // for logging purposes but won't filter by it
    let actualRunId = runId;

    let query = supabase
      .from('just_listed')
      .select('id,zpid,imgsrc,detailurl,addressstreet,lastcity,addresscity,addressstate,addresszipcode,price,unformattedprice,beds,baths,area,statustext,lastseenat,created_at,ai_analysis', { count: 'exact' })
      .order('lastseenat', { ascending: false })
      .range(from, to);

    if (cityName) {
      if (Array.isArray(cityName)) {
        // Multiple cities
        query = query.in('lastcity', cityName);
      } else {
        // Single city - try both lastcity and addresscity columns
        query = query.or(`lastcity.eq.${cityName},addresscity.eq.${cityName}`);
      }
    }
    
    // Date filtering
    if (filters.dateRange && filters.dateRange !== 'all') {
      if (typeof filters.dateRange === 'object' && filters.dateRange.type === 'custom') {
        // Custom date range (specific day)
        query = query.gte('lastseenat', filters.dateRange.startDate);
        query = query.lte('lastseenat', filters.dateRange.endDate);
      } else {
        // Preset date range (last X days)
        const days = parseInt(filters.dateRange);
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - days);
        query = query.gte('lastseenat', cutoffDate.toISOString());
      }
    }
    
    if (filters.minPrice) {
      query = query.gte('unformattedprice', filters.minPrice);
    }
    if (filters.maxPrice) {
      query = query.lte('unformattedprice', filters.maxPrice);
    }
    if (filters.beds) {
      query = query.gte('beds', filters.beds);
    }
    if (filters.baths) {
      query = query.gte('baths', filters.baths);
    }
    if (filters.propertyType) {
      query = query.eq('statustext', filters.propertyType);
    }
    if (filters.minSqft) {
      query = query.gte('area', filters.minSqft);
    }
    if (filters.maxSqft) {
      query = query.lte('area', filters.maxSqft);
    }
    
    // Search term filter - search across address, city, state, and zip
    if (filters.searchTerm && filters.searchTerm.trim()) {
      const searchTerm = filters.searchTerm.trim();
      query = query.or(`addressstreet.ilike.%${searchTerm}%,lastcity.ilike.%${searchTerm}%,addresscity.ilike.%${searchTerm}%,addressstate.ilike.%${searchTerm}%,addresszipcode.ilike.%${searchTerm}%`);
    }
    
    // AI Furniture Filter - only show properties with furniture if enabled
    if (filters.aiFurnitureFilter) {
      // Use the database function we created to check for furniture
      query = query.filter('ai_analysis', 'not.is', null)
                   .filter('ai_analysis->has_furniture', 'eq', true);
    }

    const { data, error, count } = await query;

    if (error) {
      throw handleDatabaseError(error, 'fetchJustListed', {
        table: 'just_listed',
        operation: 'select_listings',
        runId: actualRunId,
        cityName,
        page,
        pageSize,
        filters
      });
    }
    
    
    // Map database column names to expected property names
    const mappedData = (data || []).map((r) => ({
      id: r.id, // Keep as number to match database BIGINT
      zpid: r.zpid,
      imgSrc: r.imgsrc,
      detailUrl: r.detailurl,
      addressStreet: r.addressstreet, // Map lowercase DB column to camelCase frontend property
      lastcity: r.lastcity,
      addresscity: r.addresscity,
      addressstate: r.addressstate,
      addressZipcode: r.addresszipcode,
      price: r.price,
      unformattedprice: r.unformattedprice, // Use lowercase to match component
      beds: r.beds,
      baths: r.baths,
      area: r.area,
      statustext: r.statustext, // Use lowercase to match component
      lastseenat: r.lastseenat,
      created_at: r.created_at,
      ai_analysis: r.ai_analysis // Include AI analysis results
    }));
    
    return { data: mappedData, count: count || 0 };
  } catch (error) {
    
    // Provide more specific error information
    if (error.code === 'PGRST116') {
      throw new Error('No data found for the specified criteria. Please check your filters or try again later.');
    } else if (error.code === 'PGRST301') {
      throw new Error('Database connection issue. Please try again in a moment.');
    } else if (error.message?.includes('column') || error.message?.includes('does not exist')) {
      throw new Error('Database structure issue. Please contact support.');
    }
    
    throw error;
  }
}

export async function fetchSoldSincePrev(currentRunId, prevRunId, cityName, filters = {}) {
  try {

    // Query sold_listings table directly instead of using RPC
    // Since sold_listings doesn't have run_id column, we'll query without it
    let query = supabase
      .from('sold_listings')
      .select('id,zpid,imgsrc,detailurl,addressstreet,lastcity,addresscity,addressstate,addresszipcode,price,unformattedprice,beds,baths,area,statustext,lastseenat,created_at');

    if (cityName) {
      if (Array.isArray(cityName)) {
        // Multiple cities
        query = query.in('lastcity', cityName);
      } else {
        // Single city
        query = query.eq('lastcity', cityName);
      }
    }

    // Date filtering
    if (filters.dateRange && filters.dateRange !== 'all') {
      if (typeof filters.dateRange === 'object' && filters.dateRange.type === 'custom') {
        // Custom date range (specific day)
        query = query.gte('lastseenat', filters.dateRange.startDate);
        query = query.lte('lastseenat', filters.dateRange.endDate);
      } else {
        // Preset date range (last X days)
        const days = parseInt(filters.dateRange);
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - days);
        query = query.gte('lastseenat', cutoffDate.toISOString());
      }
    }
    
    // Search term filter - search across address, city, state, and zip
    if (filters.searchTerm && filters.searchTerm.trim()) {
      const searchTerm = filters.searchTerm.trim();
      query = query.or(`addressstreet.ilike.%${searchTerm}%,lastcity.ilike.%${searchTerm}%,addresscity.ilike.%${searchTerm}%,addressstate.ilike.%${searchTerm}%,addresszipcode.ilike.%${searchTerm}%`);
    }

    const { data, error } = await query;

    if (error) {
      throw handleDatabaseError(error, 'fetchSoldSincePrev', {
        table: 'sold_listings',
        operation: 'select_sold_listings',
        currentRunId,
        prevRunId,
        cityName,
        filters
      });
    }
    
    let filteredData = data ?? [];

    if (Object.keys(filters).length > 0) {
      filteredData = filteredData.filter(listing => {
      if (filters.minPrice && listing.unformattedprice < filters.minPrice) return false;
      if (filters.maxPrice && listing.unformattedprice > filters.maxPrice) return false;
          if (filters.beds && listing.beds < filters.beds) return false;
          if (filters.baths && listing.baths < filters.baths) return false;
          if (filters.propertyType && listing.statustext !== filters.propertyType) return false;
          if (filters.minSqft && listing.area < filters.minSqft) return false;
          if (filters.maxSqft && listing.area > filters.maxSqft) return false;
          return true;
      });
    }

    const mappedData = filteredData.map((r) => ({
      id: r.id, // Keep as number to match database BIGINT
      zpid: r.zpid,
      imgSrc: r.imgsrc,
      detailUrl: r.detailurl,
      addressStreet: r.addressstreet, // Map lowercase DB column to camelCase frontend property
      lastcity: r.lastcity,
      addresscity: r.addresscity,
      addressstate: r.addressstate,
      addressZipcode: r.addresszipcode,
      price: r.price,
      unformattedprice: r.unformattedprice, // Use lowercase to match component
      beds: r.beds,
      baths: r.baths,
      area: r.area,
      statustext: r.statustext, // Use lowercase to match component
      lastseenat: r.lastseenat,
      created_at: r.created_at
    }));

    return mappedData;
  } catch (error) {
    throw error;
  }
}

export async function fetchListingById(listingId) {
  // Ensure listingId is a number for proper database query
  const numericId = Number(listingId);
  
  if (isNaN(numericId)) {
    throw new Error('Invalid listing ID');
  }

  // Try to find the listing in just_listed first, then sold_listings
  let { data, error } = await supabase
    .from('just_listed')
    .select('*')
    .eq('id', numericId)
    .single();

  if (error || !data) {
    // If not found in just_listed, try sold_listings
    const { data: soldData, error: soldError } = await supabase
      .from('sold_listings')
      .select('*')
      .eq('id', numericId)
      .single();

    if (soldError) {
      throw soldError;
    }
    data = soldData;
  }

  if (!data) {
    return null;
  }

  // Map database column names to expected property names (consistent with other fetch functions)
  const mappedData = {
    id: data.id, // Keep as number to match database BIGINT
    zpid: data.zpid,
    imgSrc: data.imgsrc,
    detailUrl: data.detailurl,
    addressStreet: data.addressstreet, // Map lowercase DB column to camelCase frontend property
    lastcity: data.lastcity,
    addresscity: data.addresscity,
    addressstate: data.addressstate,
    addressZipcode: data.addresszipcode,
    price: data.price,
    unformattedprice: data.unformattedprice, // Use lowercase to match component
    beds: data.beds,
    baths: data.baths,
    area: data.area,
    statustext: data.statustext, // Use lowercase to match component
    lastseenat: data.lastseenat,
    created_at: data.created_at,
    run_id: data.run_id || data.lastrunid,
    isjustlisted: data.isjustlisted,
    
    // JSONB fields (parse if they're strings)
    latlong: typeof data.latlong === 'string' 
      ? JSON.parse(data.latlong) 
      : data.latlong,
    hdpData: typeof data.hdpdata === 'string' 
      ? JSON.parse(data.hdpdata) 
      : data.hdpdata,
    carouselPhotos: typeof data.carouselphotos === 'string' 
      ? JSON.parse(data.carouselphotos) 
      : data.carouselphotos,
    carouselPhotosComposable: typeof data.carousel_photos_composable === 'string' 
      ? JSON.parse(data.carousel_photos_composable) 
      : data.carousel_photos_composable,
    
    // Additional fields that might be needed
    brokerName: data.brokername || data.broker_name,
    detailurl: data.detailurl,
  };

  return mappedData;
}

// Note: Zillow URL functions removed - external links now admin-only

export async function fetchRevealedListings(userId, listingIds) {
  if (!userId || !listingIds || listingIds.length === 0) {
    return [];
  }
  
  // Ensure all listing IDs are numbers
  const numericListingIds = listingIds.map(id => {
    const numId = Number(id);
    if (isNaN(numId)) {
      return null;
    }
    return numId;
  }).filter(Boolean);

  if (numericListingIds.length === 0) {
    return [];
  }

  const { data, error } = await supabase
    .from('listing_reveals')
    .select('listing_id')
    .eq('user_id', userId)
    .in('listing_id', numericListingIds);

  if (error) {
    throw error;
  }

  return data || [];
}